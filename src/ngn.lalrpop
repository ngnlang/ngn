use crate::ast::*;
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        Var => Token::Var,
        Const => Token::Const,
        Lit => Token::Lit,
        Static => Token::Static,
        If => Token::If,
        Not => Token::Not,
        While => Token::While,
        Until => Token::Until,
        Match => Token::Match,
        One => Token::One,
        Any => Token::Any,
        Once => Token::Once,
        Echo => Token::Echo,
        Print => Token::Print,
        Break => Token::Break,
        Next => Token::Next,
        True => Token::True,
        False => Token::False,
        End => Token::End,
        Newline => Token::Newline,
        Return => Token::Return,
        Fn => Token::Fn,
        
        StarStar => Token::StarStar,
        EqEq => Token::EqEq,
        NotEq => Token::NotEq,
        LessEq => Token::LessEq,
        GreaterEq => Token::GreaterEq,
        OrOr => Token::OrOr,

        PlusEq => Token::PlusEq,
        MinusEq => Token::MinusEq,
        StarEq => Token::StarEq,
        SlashEq => Token::SlashEq,
        PercentEq => Token::PercentEq,
        StarStarEq => Token::StarStarEq,
        CaretEq => Token::CaretEq,
        
        Plus => Token::Plus,
        Minus => Token::Minus,
        Star => Token::Star,
        Slash => Token::Slash,
        Percent => Token::Percent,
        Caret => Token::Caret,
        Eq => Token::Eq,
        Less => Token::Less,
        Greater => Token::Greater,
        Colon => Token::Colon,
        Comma => Token::Comma,
        LParen => Token::LParen,
        RParen => Token::RParen,
        LBracket => Token::LBracket,
        RBracket => Token::RBracket,
        LBrace => Token::LBrace,
        RBrace => Token::RBrace,
        
        "Ident" => Token::Ident(<String>),
        "String" => Token::String(<String>),
        "Number" => Token::Number(<f64>),
    }
}

pub Program: Vec<Stmt> = {
    <stmts:StatementLine*> => stmts,
};

StatementLine: Stmt = {
    <stmt:Statement> <_nl:Newline*> => stmt,
};

Statement: Stmt = {
    IfStmt,
    WhileStmt,
    WhileOnceStmt,
    UntilStmt,
    UntilOnceStmt,
    MatchStmt,
    FnDefStmt,
    SimpleStatement,
};

BreakStmt: Stmt = {
    Break => Stmt::Break,
};

NextStmt: Stmt = {
    Next => Stmt::Next,
};

EchoStmt: Stmt = {
    Echo LParen <e:Expr> RParen => Stmt::Echo(e),
};

PrintStmt: Stmt = {
    Print LParen <e:Expr> RParen => Stmt::Print(e),
};

FnDefStmt: Stmt = {
    Fn <name:Ident> LParen <params:FnParams?> RParen <return_type:FnReturnType?> <_nl:Newline> <body:FnBody> End => {       
        Stmt::FnDef {
            name,
            params: params.unwrap_or_default(),
            return_type,
            body,
        }
    },
    Fn <name:Ident> LParen <params:FnParams?> RParen <return_type:FnReturnType?> <expr:Expr> <_nl:Newline> => {
        let ret_stmt = Stmt::Return(Some(expr));
        Stmt::FnDef {
            name,
            params: params.unwrap_or_default(),
            return_type,
            body: vec![ret_stmt],
        }
    },
};

FnBody: Vec<Stmt> = {
    <stmts:StatementLine*> <ret:ReturnStmt> => {
        let mut all = stmts;
        all.push(ret);
        all
    },
    <stmts:StatementLine*> => stmts,
};

FnParams: Vec<(String, Option<Type>)> = {
    <first:FnParam> <rest:(Comma <FnParam>)*> => {
        let mut all = vec![first];
        all.extend(rest);
        all
    },
};

FnParam: (String, Option<Type>) = {
    <name:Ident> <ty:TypeAnnotation?> => (name, ty),
};

FnReturnType: Type = {
    Colon <t:TypeName> => t,
};

ReturnStmt: Stmt = {
    Return Newline => Stmt::Return(None),
    Return <e:ReturnExpr> => Stmt::Return(Some(e)),
};

ReturnExpr: Expr = {
    <e:Expr> Newline => e,
};

IfStmt: Stmt = {
    If <negated:Not?> LParen <cond:Expr> RParen <then_body:IfBodySingleLine> <else_ifs:ElseIfClauseSingleLine*> <else_clause:ElseClauseSingleLine?> <_nl:Newline> => {
        let condition = if negated.is_some() {
            crate::ast::Expr::Not(Box::new(cond))
        } else {
            cond
        };
        Stmt::If {
            condition,
            then_block: then_body,
            else_ifs,
            else_block: else_clause,
        }
    },
    If <negated:Not?> LParen <cond:Expr> RParen <_nl:Newline> <then_body:IfBodyMultiLine> <else_ifs:ElseIfClauseMultiLine*> <else_clause:ElseClauseMultiLine?> End => {
        let condition = if negated.is_some() {
            crate::ast::Expr::Not(Box::new(cond))
        } else {
            cond
        };
        Stmt::If {
            condition,
            then_block: then_body,
            else_ifs,
            else_block: else_clause,
        }
    },
};

IfBodySingleLine: Vec<Stmt> = {
    <stmt:SimpleStatement> => vec![stmt],
};

IfBodyMultiLine: Vec<Stmt> = {
    <stmts:StatementLine+> => stmts,
};

SimpleStatement: Stmt = {
    BreakStmt,
    NextStmt,
    EchoStmt,
    PrintStmt,
    AssignStmt,
    ReassignStmt,
    ExprStmt,
};

ElseIfClauseSingleLine: (Expr, Vec<Stmt>) = {
    Colon <negated:Not?> LParen <cond:Expr> RParen <body:IfBodySingleLine> => {
        let condition = if negated.is_some() {
            crate::ast::Expr::Not(Box::new(cond))
        } else {
            cond
        };
        (condition, body)
    },
};

ElseIfClauseMultiLine: (Expr, Vec<Stmt>) = {
    Colon <_nl:Newline*> <negated:Not?> LParen <cond:Expr> RParen Newline? <body:IfBodyMultiLine> => {
        let condition = if negated.is_some() {
            crate::ast::Expr::Not(Box::new(cond))
        } else {
            cond
        };
        (condition, body)
    },
};

ElseClauseSingleLine: Vec<Stmt> = {
    Colon <body:IfBodySingleLine> => body,
};

ElseClauseMultiLine: Vec<Stmt> = {
    Colon <_nl:Newline*> <body:IfBodyMultiLine> => body,
};

IfBody: Vec<Stmt> = {
    <stmts:Statement+> => stmts,
}

ExprStmt: Stmt = {
    <name:Ident> LParen <args:FnCallArgList?> RParen => {
        Stmt::ExprStmt(Expr::Call { name, args: args.unwrap_or_default() })
    },
};

WhileStmt: Stmt = {
    While LParen <cond:Expr> RParen <body:WhileBodySingleLine> <_nl:Newline> => {
        Stmt::While { condition: cond, body }
    },
    While LParen <cond:Expr> RParen <_nl:Newline> <body:WhileBodyMultiLine> End => {
        Stmt::While { condition: cond, body }
    },
};

WhileOnceStmt: Stmt = {
    While Once LParen <cond:Expr> RParen <body:WhileBodySingleLine> <_nl:Newline> => {
        Stmt::WhileOnce { condition: cond, body }
    },
    While Once LParen <cond:Expr> RParen <_nl:Newline> <body:WhileBodyMultiLine> End => {
        Stmt::WhileOnce { condition: cond, body }
    },
};

WhileBodySingleLine: Vec<Stmt> = {
    <stmt:SimpleStatement> => vec![stmt],
};

WhileBodyMultiLine: Vec<Stmt> = {
    <stmts:StatementLine+> => stmts,
};

UntilStmt: Stmt = {
    Until LParen <cond:Expr> RParen <body:UntilBodySingleLine> <_nl:Newline> => {
        Stmt::Until { condition: cond, body }
    },
    Until LParen <cond:Expr> RParen <_nl:Newline> <body:UntilBodyMultiLine> End => {
        Stmt::Until { condition: cond, body }
    },
};

UntilOnceStmt: Stmt = {
    Until Once LParen <cond:Expr> RParen <body:UntilBodySingleLine> <_nl:Newline> => {
        Stmt::UntilOnce { condition: cond, body }
    },
    Until Once LParen <cond:Expr> RParen <_nl:Newline> <body:UntilBodyMultiLine> End => {
        Stmt::UntilOnce { condition: cond, body }
    },
};

UntilBodySingleLine: Vec<Stmt> = {
    <stmt:SimpleStatement> => vec![stmt],
};

UntilBodyMultiLine: Vec<Stmt> = {
    <stmts:StatementLine+> => stmts,
};

MatchStmt: Stmt = {
    MatchOne,
    MatchAny,
};

MatchOne: Stmt = {
    Match One LParen <expr:Expr> RParen Newline <cases:MatchCase*> <default:MatchDefault?> End => {
        Stmt::Match {
            expr,
            cases,
            default,
            match_type: crate::ast::MatchType::One,
        }
    },
};

MatchAny: Stmt = {
    Match Any LParen <expr:Expr> RParen Newline <cases:MatchCase*> <default:MatchDefault?> End => {
        Stmt::Match {
            expr,
            cases,
            default,
            match_type: crate::ast::MatchType::Any,
        }
    },
};

MatchCase: (Vec<Expr>, Vec<Stmt>) = {
    Colon <tests:MatchTest> Newline <body:StatementLine+> => (tests, body),
};

MatchTest: Vec<Expr> = {
    <first:MatchLiteral> <rest:(OrOr <MatchLiteral>)*> => {
        let mut result = vec![first];
        result.extend(rest);
        result
    },
};

MatchLiteral: Expr = {
    <n:"Number"> => crate::ast::Expr::Number(n),
    <s:"String"> => crate::ast::Expr::String(s),
    True => crate::ast::Expr::Bool(true),
    False => crate::ast::Expr::Bool(false),
};

MatchDefault: Vec<Stmt> = {
    Colon Newline? <body:IfBody> Newline => body,
};

AssignStmt: Stmt = {
    <kind:AssignKind> <name:Ident> <ty:TypeAnnotation?> Eq <value:Expr> => {
        Stmt::Assign {
            kind,
            declared_type: ty,
            name,
            value,
        }
    },
};

AssignKind: AssignKind = {
    Var => AssignKind::Var,
    Const => AssignKind::Const,
    Lit => AssignKind::Lit,
    Static => AssignKind::Static,
};

ReassignStmt: Stmt = {
    <name:Ident> Eq <value:Expr> => {
        Stmt::Reassign { name, value }
    },
};

Expr: Expr = {
    <name:Ident> <op:CompoundOp> <value:Expr> => {
        let expanded = match op.as_str() {
            "+=" => Expr::Add(Box::new(Expr::Var(name.clone())), Box::new(value)),
            "-=" => Expr::Subtract(Box::new(Expr::Var(name.clone())), Box::new(value)),
            "*=" => Expr::Multiply(Box::new(Expr::Var(name.clone())), Box::new(value)),
            "/=" => Expr::Divide(Box::new(Expr::Var(name.clone())), Box::new(value)),
            "%=" => Expr::Modulo(Box::new(Expr::Var(name.clone())), Box::new(value)),
            "**=" => Expr::Power(Box::new(Expr::Var(name.clone())), Box::new(value)),
            "^=" => Expr::Power(Box::new(Expr::Var(name.clone())), Box::new(value)),
            _ => unreachable!(),
        };
        Expr::CompoundAssign { name, op, value: Box::new(expanded) }
    },
    <name:Ident> Eq <value:Expr> => {
        Expr::Assign { name, value: Box::new(value) }
    },
    Comparison,
};

AndExpr: Expr = {
    Comparison,
};

Comparison: Expr = {
    <left:Addition> <rest:(CompOp Addition)*> => {
        rest.into_iter().fold(left, |acc, (op, right)| {
            match op.as_str() {
                "==" => Expr::Equal(Box::new(acc), Box::new(right)),
                "!=" => Expr::NotEqual(Box::new(acc), Box::new(right)),
                "<" => Expr::LessThan(Box::new(acc), Box::new(right)),
                "<=" => Expr::LessThanOrEqual(Box::new(acc), Box::new(right)),
                ">" => Expr::GreaterThan(Box::new(acc), Box::new(right)),
                ">=" => Expr::GreaterThanOrEqual(Box::new(acc), Box::new(right)),
                _ => unreachable!(),
            }
        })
    },
};

Addition: Expr = {
    <left:Addition> <op:AddOp> <_nl:Newline*> <right:Multiplication> => {
        match op.as_str() {
            "+" => Expr::Add(Box::new(left), Box::new(right)),
            "-" => Expr::Subtract(Box::new(left), Box::new(right)),
            _ => unreachable!(),
        }
    },
    Multiplication,
};

Multiplication: Expr = {
    <left:Multiplication> <op:MulOp> <_nl:Newline*> <right:Unary> => {
        match op.as_str() {
            "*" => Expr::Multiply(Box::new(left), Box::new(right)),
            "/" => Expr::Divide(Box::new(left), Box::new(right)),
            "%" => Expr::Modulo(Box::new(left), Box::new(right)),
            _ => unreachable!(),
        }
    },
    Unary,
};

Unary: Expr = {
    Power,
    Plus <e:Power> => e,
    Minus <e:Power> => Expr::Negative(Box::new(e)),
};

Power: Expr = {
    <base:Factor> PowerOp <_nl:Newline*> <exp:Power> => Expr::Power(Box::new(base), Box::new(exp)),
    Factor,
};

Factor: Expr = {
    Number,
    String,
    Bool,
    Array,
    <name:Ident> LParen <args:FnCallArgList?> RParen => {
        Expr::Call { name, args: args.unwrap_or_default() }
    },
    <i:Ident> => Expr::Var(i),
    LParen <_nl:Newline*> <e:Expr> <_nl2:Newline*> RParen => e,
};

FnCallArgList: Vec<Expr> = {
    <_nl:Newline*> <first:Expr> <rest:FnCallArg*> => {
        let mut all = vec![first];
        all.extend(rest);
        all
    },
};

FnCallArg: Expr = {
    Comma <_nl:Newline*> <e:Expr> <_nl2:Newline*> => e,
};

Number: Expr = {
    <n:"Number"> => crate::ast::Expr::Number(n),
};

String: Expr = {
    <s:"String"> => crate::ast::Expr::String(s),
};

Bool: Expr = {
    True => crate::ast::Expr::Bool(true),
    False => crate::ast::Expr::Bool(false),
};

Array: Expr = {
    LBracket RBracket => Expr::Array(vec![]),
    LBracket <first:Multiplication> <rest:(Comma <Multiplication>)*> RBracket => {
        let mut all = vec![first];
        all.extend(rest);
        Expr::Array(all)
    },
};

CompoundOp: String = {
    PlusEq => "+=".to_string(),
    MinusEq => "-=".to_string(),
    StarEq => "*=".to_string(),
    SlashEq => "/=".to_string(),
    PercentEq => "%=".to_string(),
    StarStarEq => "**=".to_string(),
    CaretEq => "^=".to_string(),
};

AddOp: String = {
    Plus => "+".to_string(),
    Minus => "-".to_string(),
};

MulOp: String = {
    Star => "*".to_string(),
    Slash => "/".to_string(),
    Percent => "%".to_string(),
};

CompOp: String = {
    EqEq => "==".to_string(),
    NotEq => "!=".to_string(),
    LessEq => "<=".to_string(),
    GreaterEq => ">=".to_string(),
    Less => "<".to_string(),
    Greater => ">".to_string(),
};

PowerOp: String = {
    StarStar => "**".to_string(),
    Caret => "^".to_string(),
};

TypeAnnotation: Type = {
    Colon <t:TypeName> => t,
};

TypeName: Type = {
    <s:"Ident"> => {
        match s.as_str() {
            "number" => Type::Number,
            "string" => Type::String,
            "bool" => Type::Bool,
            "array" => Type::Array(Box::new(Type::Number)),
            "void" => Type::Void,
            _ => panic!("Unknown type: {}", s),
        }
    },
    <s:"Ident"> Less <inner:TypeName> Greater => {
        match s.as_str() {
            "array" => Type::Array(Box::new(inner)),
            _ => panic!("Unknown parameterized type: {}", s),
        }
    },
};

Ident: String = {
    <s:"Ident"> => s,
};
